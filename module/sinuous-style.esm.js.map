{"version":3,"file":"sinuous-style.esm.js","sources":["../src/utils.js","../src/scopeStyles.js","../src/index.js"],"sourcesContent":["export const isFunction = (item) => typeof item === 'function';\n","import { isFunction } from './utils';\n\n// Token types\nconst RULE_BLOCK = 1;\nconst COMMA = 2;\nconst AT_RULE = 3;\nconst WHITESPACE = 4;\nconst LIMITER = 5;\nconst FUNCTION = 6;\nconst SELECTOR = 7;\nconst END = 8;\n\n/**\n * Tokenizes an array of style strings from a <style /> element.\n * Style elements can contain observables (or other values),\n * making the array of the following form:\n *\n * ['div { background: ', observableFn, '; }']\n *\n * Note: only obserables within a rule-block are expected.\n * Observables or other values in the place of selectors\n * or other css entities will lead to unexpected behavior.\n *\n * @param {Array} styles - An array of strings potentially interspersed with observables and other values\n * @return {Array} An array of tokens: RULE_BLOCK | COMMA | AT_RULE | WHITESPACE | LIMITER | FUNCTION | SELECTOR\n */\nfunction tokenize(styles) {\n  styles = styles.flatMap((section) =>\n    typeof section === 'string' ? section.split('') : section\n  );\n\n  let tokens = [];\n  let bracketStack = 0;\n  let chars = [];\n  let type;\n\n  function pushToken() {\n    tokens.push({\n      token: chars.join(''),\n      type,\n    });\n    type = undefined;\n    chars = [];\n  }\n\n  let char;\n  let charsLength;\n  for (let i = 0; i < styles.length; i++) {\n    char = styles[i];\n    charsLength = chars.length;\n    if (isFunction(char)) {\n      if (charsLength) {\n        pushToken();\n      }\n      tokens.push({ token: char, type: FUNCTION });\n    } else if (bracketStack) {\n      if (!charsLength) {\n        type = RULE_BLOCK;\n      }\n      chars.push(char);\n      if (char === '{') {\n        bracketStack++;\n      } else if (char === '}') {\n        bracketStack--;\n        if (!bracketStack) {\n          pushToken();\n        }\n      }\n    } else {\n      if (char === '{') {\n        if (charsLength) {\n          pushToken();\n        }\n        bracketStack++;\n        type = RULE_BLOCK;\n        chars.push(char);\n      } else if (char === ',') {\n        if (charsLength && type !== AT_RULE) {\n          pushToken();\n        }\n        type = COMMA;\n        chars.push(char);\n        pushToken();\n      } else if ('>+~'.includes(char) && type !== SELECTOR) {\n        if (charsLength && type !== AT_RULE) {\n          pushToken();\n          tokens.push({ token: char, type: LIMITER });\n        } else {\n          chars.push(char);\n        }\n      } else if (' \\n\\t\\r'.includes(char)) {\n        if (charsLength && ![WHITESPACE, AT_RULE].includes(type)) {\n          pushToken();\n        }\n        type = WHITESPACE;\n        chars.push(char);\n      } else if (char === '@') {\n        if (charsLength) {\n          pushToken();\n        }\n        type = AT_RULE;\n        chars.push(char);\n      } else {\n        if (!charsLength) {\n          type = SELECTOR;\n          chars.push(char);\n        } else if ([SELECTOR, AT_RULE].includes(type)) {\n          chars.push(char);\n        } else {\n          pushToken();\n          type = SELECTOR;\n          chars.push(char);\n        }\n      }\n    }\n  }\n\n  if (chars.length) {\n    pushToken();\n  }\n\n  return tokens;\n}\n\n/**\n * Adds the `scopeName` after tags but before ids, other classNames,\n * pseudoSelectors, and attribute selectors. For example:\n *\n * `div.some-class` becomes `div.<scopeName>.some-class`\n *\n * @param {String} selector - A css selector\n * @param {String} scopeName - The className used to scope the `selector`\n * @return {String}\n */\nfunction insertScopeName(selector, scopeName) {\n  let i = 0;\n  while (!'#.:['.includes(selector[i]) && i !== selector.length) {\n    i++;\n  }\n  let first = selector.slice(0, i);\n  let second = selector.slice(i);\n  return first + '.' + scopeName + second;\n}\n\n/**\n * @param {Array} styleTokens - The result of `tokenize(styles)`\n * @param {String} scopeName - The className used to scope the `Selector` tokens\n * @return {Array} An array of the form of `styles` passed to `tokenize`,\n * but with all the selectors scoped to `scopeName`\n */\nfunction scopeSelectors(styleTokens, scopeName) {\n  styleTokens.push({ type: END });\n  let styles = styleTokens.reduce(\n    (acc, token) => {\n      let current = acc[0];\n      let sections = acc[1];\n      if (token.type === SELECTOR) {\n        current.push(insertScopeName(token.token, scopeName));\n      } else if (token.type === FUNCTION) {\n        sections.push(current.join(''));\n        sections.push(token.token);\n        current = [];\n      } else if (token.type === END) {\n        sections.push(current.join(''));\n        return sections;\n      } else {\n        current.push(token.token);\n      }\n      return [current, sections];\n    },\n    [\n      [], // current section\n      [], // sections thus far\n    ]\n  );\n  return styles;\n}\n\n/**\n * Scopes `styles` from a <style /> element.\n * Style elements can contain observables (or other values),\n * making the `styles` array of the following form:\n *\n * ['div.classes { background: ', observableFn, '; }']\n *\n * It returns an array of the following form:\n *\n * ['div.scopeName.classes { background: ', observableFn, '; }']\n *\n * Note: only obserables within a rule-block are expected.\n * Observables or other values in the place of selectors\n * or other css entities will lead to unexpected behavior.\n *\n * @param {Array} styles - An array of style strings and inclusions (observables and other values)\n * @param {Array} scopeName - A string representing a className to inject into the styles\n * @return {Array} A `styles` array but with css selectors now scoped to the `scopeName`\n */\nexport function scopeStyles(styles, scopeName) {\n  return scopeSelectors(tokenize(styles), scopeName);\n}\n","import { scopeStyles } from './scopeStyles';\nimport { api, html as sinuousHtml, svg as sinuousSvg } from 'sinuous';\nimport { root, cleanup } from 'sinuous/observable';\nimport { isFunction } from './utils';\n\nlet scopeName;\nlet scopeNameCounts = {};\nlet styleElementIds = new Set([]);\n\nconst pipe = (f, g) => (...args) => g(...f(...args));\n\nlet originalH = api.h;\n// Wrap the native apis\napi.h = pipe(scopeElementClasses, api.h);\napi.hs = pipe(\n  // Assume there will be no style elements nested inside svg\n  injectScopeName,\n  api.hs\n);\n\nlet head = document.querySelector('head');\n\nfunction addStyleElement(styleElement) {\n  head.append(styleElement);\n}\nfunction removeStyleByClassName(className) {\n  for (let element of head.querySelectorAll('.' + className)) {\n    if (element.nodeName === 'STYLE') {\n      /*\n        Remove the style element id from the styleElementIds so that if another\n        corresponding component is added, the style element will again\n        be appended to the dom.\n      */\n      styleElementIds.delete(element.id);\n      // Remove the style element from the dom.\n      element.remove();\n    }\n  }\n}\n\n/* \n  If an appropriate style element, scope all selectors and inject the style element\n  directly onto the body of the page. Otherwise, inject the scopeName. Return the\n  `args` to be passed into `api.h`.\n*/\nfunction scopeElementClasses(...args) {\n  if (args[0] === 'style' && args[1] && (args[1].local || args[1].global)) {\n    let props = args[1];\n    let local = props.local;\n    let className = props.class;\n    props.class = scopeName + ' ' + (props.class || '');\n    let modifiedScopeName =\n      (local ? scopeName + '-local' : scopeName + '-global') +\n      (className ? '-' + className : '');\n    if (\n      styleElementIds.has(modifiedScopeName) ||\n      head.querySelector('#' + modifiedScopeName)\n    ) {\n      return [];\n    }\n    styleElementIds.add(modifiedScopeName);\n\n    /* \n      Create a style element and append it to the document head rather than\n      passing it through to be created by api.h in the normal fashion.\n    */\n    props.id = modifiedScopeName;\n    let rest = local ? scopeStyles(args.slice(2), scopeName) : args.slice(2);\n    let styleElement = root(() => originalH(args[0], props, ...rest));\n    addStyleElement(styleElement);\n\n    return [];\n  } else {\n    return injectScopeName(...args);\n  }\n}\n\n/*\n  Wraps the callback in a newScopeName.\n*/\nfunction wrapInScope(newScopeName, callback) {\n  // Keep a reference to the outer scope.\n  let outerScopeName = scopeName;\n  // Create new scope.\n  scopeName = newScopeName;\n  let result = callback();\n  // Reset the scope to the outer scope.\n  scopeName = outerScopeName;\n  return result;\n}\n\n/* \n  Inject the scopeName into every element as an additional className.\n  Ensure that passed children are scoped lexically rather than dynamically.\n  Return the `args` to be passed into `api.h` or `api.hs`.  \n*/\nfunction injectScopeName(...args) {\n  /*\n    If the node is a component wrap its children in the scope\n    of where they apppear in the markup, not the scope of this\n    component. The `$s` annotation on this component contains\n    that `scopeName`.\n\n    This makes the scope lexical rather than dynamic.\n  */\n  if (isFunction(args[0])) {\n    let staticScopeName = args[0].$s;\n    for (let i = 2; i < args.length; i++) {\n      if (isFunction(args[i])) {\n        let temp = args[i];\n        args[i] = () => wrapInScope(staticScopeName, temp);\n      }\n    }\n  }\n\n  /*\n  Set the current value of `scopeName` to a variable so that the changing \n  `scopeName` variable (in the case that the `baseClass` is a function) \n  is not captured by the closure.\n  */\n  let staticScopeName = scopeName || '';\n  if (staticScopeName) {\n    let props = args[1] || {};\n    let baseClass = props.class || '';\n    props.class = isFunction(baseClass)\n      ? () => baseClass() + ' ' + staticScopeName\n      : baseClass\n      ? baseClass + ' ' + staticScopeName\n      : staticScopeName;\n    args[1] = props;\n  }\n  return args;\n}\n\n/*\n  Wraps Sinuous `html` or `svg`. The wrapped functions handle scoping.\n\n  The usage of that wrapped function is as follows:\n    1. html('new-scope-name')`...` - sets a new scope ('new-scope-name')\n    2. html()`...` - propagates the outer scope (useful in the case of conditionals)\n    3. html`...` - blocks the outer scope\n*/\nfunction wrapApiFunction(fn) {\n  return (...args) => {\n    if (Array.isArray(args[0])) {\n      // html`...` - block outer scope\n      return wrapInScope('', () => fn(...args));\n    } else {\n      // html(scopeName)`...` - set a new scope\n      // html()`...` - propagate outer scope\n      return (...templateArgs) => {\n        return wrapInScope(args.length ? args[0] : scopeName, () => {\n          /*\n            Annotate each child function with `$s` so that any\n            child components that render passed children can give\n            their children this `scopeName` rather than the `scopeName`\n            of that component.\n\n            This makes the scope lexical rather than dynamic.\n          */\n          for (let item of templateArgs) {\n            if (isFunction(item)) {\n              item.$s = scopeName;\n            }\n          }\n\n          // Track how many elements using this particular scopeName\n          // are present on the dom.\n          let staticScopeName = scopeName;\n          if (!scopeNameCounts[staticScopeName]) {\n            scopeNameCounts[staticScopeName] = 1;\n          } else scopeNameCounts[staticScopeName]++;\n          // Remove the corresponding style elements when the\n          // number of elements using this scopeName goes to 0.\n          cleanup(() => {\n            if (--scopeNameCounts[staticScopeName] < 1) {\n              delete scopeNameCounts[staticScopeName];\n              removeStyleByClassName(staticScopeName);\n            }\n          });\n          return fn(...templateArgs);\n        });\n      };\n    }\n  };\n}\n\n// To be used in place of Sinuous `html` and `svg`\nconst html = wrapApiFunction(sinuousHtml);\nconst svg = wrapApiFunction(sinuousSvg);\n\nexport { html, svg };\n"],"names":["sinuousHtml","sinuousSvg"],"mappings":";;;AAAO,MAAM,UAAU,GAAG,CAAC,IAAI,KAAK,OAAO,IAAI,KAAK,UAAU;;ACE9D;AACA,MAAM,UAAU,GAAG,CAAC,CAAC;AACrB,MAAM,KAAK,GAAG,CAAC,CAAC;AAChB,MAAM,OAAO,GAAG,CAAC,CAAC;AAClB,MAAM,UAAU,GAAG,CAAC,CAAC;AACrB,MAAM,OAAO,GAAG,CAAC,CAAC;AAClB,MAAM,QAAQ,GAAG,CAAC,CAAC;AACnB,MAAM,QAAQ,GAAG,CAAC,CAAC;AACnB,MAAM,GAAG,GAAG,CAAC,CAAC;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,QAAQ,CAAC,MAAM,EAAE;AAC1B,EAAE,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC,OAAO;AAClC,IAAI,OAAO,OAAO,KAAK,QAAQ,GAAG,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,OAAO;AAC7D,GAAG,CAAC;AACJ;AACA,EAAE,IAAI,MAAM,GAAG,EAAE,CAAC;AAClB,EAAE,IAAI,YAAY,GAAG,CAAC,CAAC;AACvB,EAAE,IAAI,KAAK,GAAG,EAAE,CAAC;AACjB,EAAE,IAAI,IAAI,CAAC;AACX;AACA,EAAE,SAAS,SAAS,GAAG;AACvB,IAAI,MAAM,CAAC,IAAI,CAAC;AAChB,MAAM,KAAK,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC;AAC3B,MAAM,IAAI;AACV,KAAK,CAAC,CAAC;AACP,IAAI,IAAI,GAAG,SAAS,CAAC;AACrB,IAAI,KAAK,GAAG,EAAE,CAAC;AACf,GAAG;AACH;AACA,EAAE,IAAI,IAAI,CAAC;AACX,EAAE,IAAI,WAAW,CAAC;AAClB,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC1C,IAAI,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACrB,IAAI,WAAW,GAAG,KAAK,CAAC,MAAM,CAAC;AAC/B,IAAI,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;AAC1B,MAAM,IAAI,WAAW,EAAE;AACvB,QAAQ,SAAS,EAAE,CAAC;AACpB,OAAO;AACP,MAAM,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC,CAAC;AACnD,KAAK,MAAM,IAAI,YAAY,EAAE;AAC7B,MAAM,IAAI,CAAC,WAAW,EAAE;AACxB,QAAQ,IAAI,GAAG,UAAU,CAAC;AAC1B,OAAO;AACP,MAAM,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACvB,MAAM,IAAI,IAAI,KAAK,GAAG,EAAE;AACxB,QAAQ,YAAY,EAAE,CAAC;AACvB,OAAO,MAAM,IAAI,IAAI,KAAK,GAAG,EAAE;AAC/B,QAAQ,YAAY,EAAE,CAAC;AACvB,QAAQ,IAAI,CAAC,YAAY,EAAE;AAC3B,UAAU,SAAS,EAAE,CAAC;AACtB,SAAS;AACT,OAAO;AACP,KAAK,MAAM;AACX,MAAM,IAAI,IAAI,KAAK,GAAG,EAAE;AACxB,QAAQ,IAAI,WAAW,EAAE;AACzB,UAAU,SAAS,EAAE,CAAC;AACtB,SAAS;AACT,QAAQ,YAAY,EAAE,CAAC;AACvB,QAAQ,IAAI,GAAG,UAAU,CAAC;AAC1B,QAAQ,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACzB,OAAO,MAAM,IAAI,IAAI,KAAK,GAAG,EAAE;AAC/B,QAAQ,IAAI,WAAW,IAAI,IAAI,KAAK,OAAO,EAAE;AAC7C,UAAU,SAAS,EAAE,CAAC;AACtB,SAAS;AACT,QAAQ,IAAI,GAAG,KAAK,CAAC;AACrB,QAAQ,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACzB,QAAQ,SAAS,EAAE,CAAC;AACpB,OAAO,MAAM,IAAI,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,IAAI,KAAK,QAAQ,EAAE;AAC5D,QAAQ,IAAI,WAAW,IAAI,IAAI,KAAK,OAAO,EAAE;AAC7C,UAAU,SAAS,EAAE,CAAC;AACtB,UAAU,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,CAAC;AACtD,SAAS,MAAM;AACf,UAAU,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC3B,SAAS;AACT,OAAO,MAAM,IAAI,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AAC3C,QAAQ,IAAI,WAAW,IAAI,CAAC,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AAClE,UAAU,SAAS,EAAE,CAAC;AACtB,SAAS;AACT,QAAQ,IAAI,GAAG,UAAU,CAAC;AAC1B,QAAQ,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACzB,OAAO,MAAM,IAAI,IAAI,KAAK,GAAG,EAAE;AAC/B,QAAQ,IAAI,WAAW,EAAE;AACzB,UAAU,SAAS,EAAE,CAAC;AACtB,SAAS;AACT,QAAQ,IAAI,GAAG,OAAO,CAAC;AACvB,QAAQ,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACzB,OAAO,MAAM;AACb,QAAQ,IAAI,CAAC,WAAW,EAAE;AAC1B,UAAU,IAAI,GAAG,QAAQ,CAAC;AAC1B,UAAU,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC3B,SAAS,MAAM,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AACvD,UAAU,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC3B,SAAS,MAAM;AACf,UAAU,SAAS,EAAE,CAAC;AACtB,UAAU,IAAI,GAAG,QAAQ,CAAC;AAC1B,UAAU,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC3B,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA,EAAE,IAAI,KAAK,CAAC,MAAM,EAAE;AACpB,IAAI,SAAS,EAAE,CAAC;AAChB,GAAG;AACH;AACA,EAAE,OAAO,MAAM,CAAC;AAChB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,eAAe,CAAC,QAAQ,EAAE,SAAS,EAAE;AAC9C,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;AACZ,EAAE,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,QAAQ,CAAC,MAAM,EAAE;AACjE,IAAI,CAAC,EAAE,CAAC;AACR,GAAG;AACH,EAAE,IAAI,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACnC,EAAE,IAAI,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACjC,EAAE,OAAO,KAAK,GAAG,GAAG,GAAG,SAAS,GAAG,MAAM,CAAC;AAC1C,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc,CAAC,WAAW,EAAE,SAAS,EAAE;AAChD,EAAE,WAAW,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC,CAAC;AAClC,EAAE,IAAI,MAAM,GAAG,WAAW,CAAC,MAAM;AACjC,IAAI,CAAC,GAAG,EAAE,KAAK,KAAK;AACpB,MAAM,IAAI,OAAO,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3B,MAAM,IAAI,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AAC5B,MAAM,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE;AACnC,QAAQ,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC,CAAC;AAC9D,OAAO,MAAM,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE;AAC1C,QAAQ,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;AACxC,QAAQ,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AACnC,QAAQ,OAAO,GAAG,EAAE,CAAC;AACrB,OAAO,MAAM,IAAI,KAAK,CAAC,IAAI,KAAK,GAAG,EAAE;AACrC,QAAQ,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;AACxC,QAAQ,OAAO,QAAQ,CAAC;AACxB,OAAO,MAAM;AACb,QAAQ,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAClC,OAAO;AACP,MAAM,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AACjC,KAAK;AACL,IAAI;AACJ,MAAM,EAAE;AACR,MAAM,EAAE;AACR,KAAK;AACL,GAAG,CAAC;AACJ,EAAE,OAAO,MAAM,CAAC;AAChB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,WAAW,CAAC,MAAM,EAAE,SAAS,EAAE;AAC/C,EAAE,OAAO,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,SAAS,CAAC,CAAC;AACrD;;AClMA,IAAI,SAAS,CAAC;AACd,IAAI,eAAe,GAAG,EAAE,CAAC;AACzB,IAAI,eAAe,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC;AAClC;AACA,MAAM,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;AACrD;AACA,IAAI,SAAS,GAAG,GAAG,CAAC,CAAC,CAAC;AACtB;AACA,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,mBAAmB,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AACzC,GAAG,CAAC,EAAE,GAAG,IAAI;AACb;AACA,EAAE,eAAe;AACjB,EAAE,GAAG,CAAC,EAAE;AACR,CAAC,CAAC;AACF;AACA,IAAI,IAAI,GAAG,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;AAC1C;AACA,SAAS,eAAe,CAAC,YAAY,EAAE;AACvC,EAAE,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;AAC5B,CAAC;AACD,SAAS,sBAAsB,CAAC,SAAS,EAAE;AAC3C,EAAE,KAAK,IAAI,OAAO,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,GAAG,SAAS,CAAC,EAAE;AAC9D,IAAI,IAAI,OAAO,CAAC,QAAQ,KAAK,OAAO,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA,MAAM,eAAe,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;AACzC;AACA,MAAM,OAAO,CAAC,MAAM,EAAE,CAAC;AACvB,KAAK;AACL,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mBAAmB,CAAC,GAAG,IAAI,EAAE;AACtC,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,OAAO,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE;AAC3E,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AACxB,IAAI,IAAI,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;AAC5B,IAAI,IAAI,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC;AAChC,IAAI,KAAK,CAAC,KAAK,GAAG,SAAS,GAAG,GAAG,IAAI,KAAK,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC;AACxD,IAAI,IAAI,iBAAiB;AACzB,MAAM,CAAC,KAAK,GAAG,SAAS,GAAG,QAAQ,GAAG,SAAS,GAAG,SAAS;AAC3D,OAAO,SAAS,GAAG,GAAG,GAAG,SAAS,GAAG,EAAE,CAAC,CAAC;AACzC,IAAI;AACJ,MAAM,eAAe,CAAC,GAAG,CAAC,iBAAiB,CAAC;AAC5C,MAAM,IAAI,CAAC,aAAa,CAAC,GAAG,GAAG,iBAAiB,CAAC;AACjD,MAAM;AACN,MAAM,OAAO,EAAE,CAAC;AAChB,KAAK;AACL,IAAI,eAAe,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;AAC3C;AACA;AACA;AACA;AACA;AACA,IAAI,KAAK,CAAC,EAAE,GAAG,iBAAiB,CAAC;AACjC,IAAI,IAAI,IAAI,GAAG,KAAK,GAAG,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AAC7E,IAAI,IAAI,YAAY,GAAG,IAAI,CAAC,MAAM,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;AACtE,IAAI,eAAe,CAAC,YAAY,CAAC,CAAC;AAClC;AACA,IAAI,OAAO,EAAE,CAAC;AACd,GAAG,MAAM;AACT,IAAI,OAAO,eAAe,CAAC,GAAG,IAAI,CAAC,CAAC;AACpC,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA,SAAS,WAAW,CAAC,YAAY,EAAE,QAAQ,EAAE;AAC7C;AACA,EAAE,IAAI,cAAc,GAAG,SAAS,CAAC;AACjC;AACA,EAAE,SAAS,GAAG,YAAY,CAAC;AAC3B,EAAE,IAAI,MAAM,GAAG,QAAQ,EAAE,CAAC;AAC1B;AACA,EAAE,SAAS,GAAG,cAAc,CAAC;AAC7B,EAAE,OAAO,MAAM,CAAC;AAChB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,eAAe,CAAC,GAAG,IAAI,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;AAC3B,IAAI,IAAI,eAAe,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;AACrC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC1C,MAAM,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;AAC/B,QAAQ,IAAI,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AAC3B,QAAQ,IAAI,CAAC,CAAC,CAAC,GAAG,MAAM,WAAW,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;AAC3D,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,eAAe,GAAG,SAAS,IAAI,EAAE,CAAC;AACxC,EAAE,IAAI,eAAe,EAAE;AACvB,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AAC9B,IAAI,IAAI,SAAS,GAAG,KAAK,CAAC,KAAK,IAAI,EAAE,CAAC;AACtC,IAAI,KAAK,CAAC,KAAK,GAAG,UAAU,CAAC,SAAS,CAAC;AACvC,QAAQ,MAAM,SAAS,EAAE,GAAG,GAAG,GAAG,eAAe;AACjD,QAAQ,SAAS;AACjB,QAAQ,SAAS,GAAG,GAAG,GAAG,eAAe;AACzC,QAAQ,eAAe,CAAC;AACxB,IAAI,IAAI,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;AACpB,GAAG;AACH,EAAE,OAAO,IAAI,CAAC;AACd,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,eAAe,CAAC,EAAE,EAAE;AAC7B,EAAE,OAAO,CAAC,GAAG,IAAI,KAAK;AACtB,IAAI,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;AAChC;AACA,MAAM,OAAO,WAAW,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;AAChD,KAAK,MAAM;AACX;AACA;AACA,MAAM,OAAO,CAAC,GAAG,YAAY,KAAK;AAClC,QAAQ,OAAO,WAAW,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,SAAS,EAAE,MAAM;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,KAAK,IAAI,IAAI,IAAI,YAAY,EAAE;AACzC,YAAY,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;AAClC,cAAc,IAAI,CAAC,EAAE,GAAG,SAAS,CAAC;AAClC,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA,UAAU,IAAI,eAAe,GAAG,SAAS,CAAC;AAC1C,UAAU,IAAI,CAAC,eAAe,CAAC,eAAe,CAAC,EAAE;AACjD,YAAY,eAAe,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;AACjD,WAAW,MAAM,eAAe,CAAC,eAAe,CAAC,EAAE,CAAC;AACpD;AACA;AACA,UAAU,OAAO,CAAC,MAAM;AACxB,YAAY,IAAI,EAAE,eAAe,CAAC,eAAe,CAAC,GAAG,CAAC,EAAE;AACxD,cAAc,OAAO,eAAe,CAAC,eAAe,CAAC,CAAC;AACtD,cAAc,sBAAsB,CAAC,eAAe,CAAC,CAAC;AACtD,aAAa;AACb,WAAW,CAAC,CAAC;AACb,UAAU,OAAO,EAAE,CAAC,GAAG,YAAY,CAAC,CAAC;AACrC,SAAS,CAAC,CAAC;AACX,OAAO,CAAC;AACR,KAAK;AACL,GAAG,CAAC;AACJ,CAAC;AACD;AACA;AACK,MAAC,IAAI,GAAG,eAAe,CAACA,MAAW,EAAE;AACrC,MAAC,GAAG,GAAG,eAAe,CAACC,KAAU;;;;"}